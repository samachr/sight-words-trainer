<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    #responseOptions {
      display: grid;
      grid-template-columns: auto auto auto;
    }
    .response-option {
      font-size: 48px;
      padding: 20px;
      flex-grow: 1;
    }
    html, body, #responseOptions {
      height: 100%;
    }
    html, body {
      margin: 0;
      padding: 0;
    }
    body {
      display: flex;
      flex-direction: column;
    }
    #overlay {
      z-index: 10;
      position: absolute;
      left: 0;
      top: 30px;
      right: 0;
      bottom: 0;
      display: grid;
      grid-template-columns: auto auto;
      background: gray;
    }
    progress {
      border-radius: 7px;
      width: 100%;
      height: 30px;
      box-shadow: 1px 1px 4px rgba( 0, 0, 0, 0.2 );
    }
    progress::-webkit-progress-bar {
      background-color: gray;
      border-radius: 0px;
    }
    progress::-webkit-progress-value {
      background-color: #3465a4;
      border-radius: 5px;
    }
    .wordlist-option {
      font-size: 20px;
      border-radius: 8px;
      margin: 5px;
      cursor: pointer;
    }
    #navigation {
      height: 30px;
      display: flex;
      justify-content: space-evenly;
    }
    #navigation > a {
      text-decoration: none;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      background: gray;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="navigation">
    <a href="?type=hear">Hear</a>
    <a href="?type=speak">Speak</a>
  </div>
  <div id="responseOptions"></div>
  <progress id="progress" value="0" max="100"> </progress>
  <div id="overlay"></div>
  <script>
    class SightWordsTrainer {
      constructor(wordLists) {
        this.wordLists = wordLists;
        this.words = []
        this.timings = {}
        this.correctIndex = -1;
        this.promptCount = 0;
        this.lastTime = new Date();
        this.animating = false;
        this.allTimings = this.loadAllTimings();
        this.stopGame();
      }

      loadAllTimings() {
        const storedTimings = localStorage.getItem("storedTimings");
        if (storedTimings) {
          return JSON.parse(storedTimings)
        } else {
          return wordLists.map(wordlist => {
            return wordlist.reduce((obj, word) => {
              obj[word] = 100000
              return obj;
            }, {})
          })
        }
      }

      saveAllTimings() {
        localStorage.setItem("storedTimings", JSON.stringify(this.allTimings));
      }

      getNthWorstWord(wordIndex) {
        const sortedTimings = Object.entries(this.timings).sort(([,a],[,b]) => b-a);
        return sortedTimings[wordIndex][0]
      }

      startGame(wordListIndex) {
        this.words = this.wordLists[wordListIndex]
        this.timings = this.allTimings[wordListIndex]
        this.newWord();
        this.hideOverlay();
      }

      showOverlay() {
        const overlay = document.getElementById('overlay')
        overlay.innerHTML = ''
        overlay.append(...this.wordLists.map((wordList, index) => {
          let result = document.createElement('button')
          result.className = 'wordlist-option'
          result.innerHTML = wordList.map(word => `<div>${word}: ${(this.allTimings[index][word]/1000).toFixed(1)}</div>`).join('')
          result.onclick = () => this.startGame(index)
          return result
        }))
        overlay.style.display = 'grid';
      }

      hideOverlay() {
        document.getElementById('overlay').style.display = 'none';
      }

      stopGame() {
        this.promptCount = 0;
        this.saveAllTimings();
        this.showOverlay();
      }

      newWord() {
        if(this.promptCount >= 10) {
          this.stopGame();
        } else {
          let nextWord = this.getNthWorstWord(0);
          if (this.words.indexOf(nextWord) == this.correctIndex) {
            nextWord = this.getNthWorstWord(1);
          }
          this.correctIndex = this.words.indexOf(nextWord);
          this.speakCurrentWord()
          this.lastTime = new Date();
          this.showWords()
        }
      }

      speakCurrentWord() {
        this.speak(this.words[this.correctIndex])
      }

      flashElement(element, color, callback) {
        const previousBackground = element.style.background
        element.style.background = color
        this.animating = true
        setTimeout(() => {
          this.animating = false
          element.style.background = previousBackground
          callback()
        }, 500);
      }

      checkWord(word, element) {
        if (this.animating) return;
        if (this.words.indexOf(word) != -1 && this.words.indexOf(word) == this.correctIndex) {
          this.promptCount++;
          this.timings[word] = new Date() - this.lastTime;
          this.flashElement(element, 'green', this.newWord.bind(this))
          return true;
        } else {
          this.timings[word] = this.timings[word] + (new Date() - this.lastTime);
          this.flashElement(element, 'red', this.newWord.bind(this))
          return false;
        }
      }

      randomWordThatIsNot(word) {
        let otherWords = this.words.slice()
        otherWords.splice(this.words.indexOf(word), 1)
        return otherWords[Math.floor(Math.random() * otherWords.length)]
      }

      randomIncorrectWord() {
        return this.randomWordThatIsNot(this.correctWord())
      }

      correctWord() {
        return this.words[this.correctIndex]
      }
    }

    class HearSightWordsTrainer extends SightWordsTrainer {
      constructor(wordLists) {
        super(wordLists)
      }

      speak(text) {
        window.speechSynthesis.cancel()
        const utterance = new SpeechSynthesisUtterance(text)
        utterance.rate = 0.8;
        utterance.lang = 'en-US';
        window.speechSynthesis.speak(utterance);
      }

      showWords() {
        const container = document.getElementById('responseOptions')
        container.innerHTML = '';
        const wordButtons = [
          ...Array(10).keys(),
          this.correctWord(),
          this.randomIncorrectWord()
        ].sort(() => Math.random() - 0.5).map(word => {
          let result = null;
          if (Number.isInteger(word)) {
            result = document.createElement('div')
          } else {
            result = document.createElement('button')
            result.innerHTML = word;
            result['ontouchstart' in window ? 'ontouchstart' : 'onclick'] = (() => this.checkWord(word, result)).bind(this)
          }
          result.id = `word-${word}`
          result.className = 'response-option'
          return result
        })
        container.append(...wordButtons)

        document.getElementById("progress").value = (this.promptCount) / 10 * 100;
        document.getElementById("progress").innerHTML = (this.promptCount) / 10 * 100;

        Object.keys(this.timings).forEach(key => this.timings[key] += 500)
      }
    }

    class SpeakSightWordsTrainer extends SightWordsTrainer {
      constructor(wordLists) {
        super(wordLists)
      }

      showWords() {}

      speak(word) {
        const container = document.getElementById('responseOptions')
        container.innerHTML = ''
        this.listenForWord(word, () => {
          const result = document.createElement('button')
          result.innerHTML = word;
          result.className = 'response-option'
          result.id = `word-${word}`
          result.style.gridColumn = '1 / span 3'
          container.appendChild(result)
        });

        document.getElementById("progress").value = (this.promptCount) / 10 * 100;
        document.getElementById("progress").innerHTML = (this.promptCount) / 10 * 100;

        Object.keys(this.timings).forEach(key => this.timings[key] += 500)
      }

      listenForWord(word, onReady) {
        const SpeechRecognition = window.SpeechRecognition || webkitSpeechRecognition;
        const SpeechGrammarList = window.SpeechGrammarList || webkitSpeechGrammarList;
        const SpeechRecognitionEvent = window.SpeechRecognitionEvent || webkitSpeechRecognitionEvent;

        var speechRecognitionList = new SpeechGrammarList();
        speechRecognitionList.addFromString('#JSGF V1.0; grammar phrases; public <phrase> = ' + this.words.join(' | ') +';', 1);

        var recognition = new SpeechRecognition();
        recognition.grammars = speechRecognitionList;
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 10;

        recognition.start();

        let matched = false;
        let ready = false;

        recognition.onresult = (event) => {
          const results = event.results
          let word = results[0][0].transcript;

          let recognizedWords = []
          for (let resultListIndex = 0; resultListIndex < event.results.length; resultListIndex++) {
            for (let resultIndex = 0; resultIndex < event.results[resultListIndex].length; resultIndex++) {
              let result = results[resultListIndex][resultIndex]
              recognizedWords.push(result.transcript)
            }
          }

          console.log(recognizedWords)
          word = recognizedWords.find(recognizedWord =>
            this.words.indexOf(recognizedWord) != -1
          )

          matched = this.checkWord(
            (word || '').toLowerCase(),
            document.getElementById(`word-${this.correctWord()}`)
          )
        }
        recognition.onspeechend = () => {
          console.log('SpeechRecognition.onspeechend')
        }

        recognition.onerror = (event) => {
          console.log('Error occurred in recognition: ' + event.error);
          this.checkWord(
            'This error is not a match!',
            document.getElementById(`word-${this.correctWord()}`),
          )
        }
        recognition.onaudiostart = (event) => {
          console.log('SpeechRecognition.onaudiostart')
          ready = true;
          onReady();
        };
        recognition.onaudioend = (event) => console.log('SpeechRecognition.onaudioend');
        recognition.onend = (event) => {
          console.log('SpeechRecognition.onend')
          if (ready && !matched && this.correctIndex != -1) {
            this.checkWord(
              'This error is not a match!',
              document.getElementById(`word-${this.correctWord()}`),
            )
          }
        };
        recognition.onnomatch = () => console.log('SpeechRecognition.onnomatch');
        recognition.onsoundstart = (event) => console.log('SpeechRecognition.onsoundstart');
        recognition.onsoundend = (event) => console.log('SpeechRecognition.onsoundend');
        recognition.onspeechstart = (event) => console.log('SpeechRecognition.onspeechstart');
        recognition.onstart = (event) => console.log('SpeechRecognition.onstart');
      }
    }

    const urlParams = new URLSearchParams(window.location.search);
    const requestedGameType = urlParams.get('type');

    const GameType = !requestedGameType || requestedGameType == 'hear' ? HearSightWordsTrainer : SpeakSightWordsTrainer

    window.game = new GameType([
      ["am", "at", "can", "go", "is"],
      ["like", "me", "see", "the", "to"],
      ["dad", "he", "in", "it", "look"],
      ["mom", "my", "on", "up", "we"],
      ["and", "are", "come", "for", "got"],
      ["here", "not", "play", "said", "you"],
      ["day", "down", "into", "looking", "she"],
      ["they", "went", "where", "will", "your"],
      ["all", "away", "back", "big", "her"],
      ["over", "this", "want", "who", "with"]
    ]);
  </script>
</body>
</html>
